~~~if TODO is done set [-] to [+]~~~
========================================
Components:
----------------------------------------
1.thread
[+]get and execute task function
	[+]lock queue
	[+]while no tasks wait for new task (condition variable)
	[+]dequeue task
	[+]unlock queue
	[+]execute task
[+]implement a function that all thread will execute (that would get and execute tasks forever)
[+]implement a "self destruct" function that would be queued to the tasks 
queue "number_of_threads" times when "tpDestroy" is invoked and would call "exit(0)" 

----------------------------------------
2.task:
[+]implement a struct that would contain a pointer to a function and a the argument to the function 
(this struct would be a member in the task queue)
----------------------------------------
3.functions to implement:
[+]tpInsertTask (NOTE: we need to make sure this function is thread-safe)
	[+]if "tpDestroy was invoked" return -1
	[+]lock queue
	[+]enqueue new task
	[+]cond_signal - wake up one thread to take care of the task
	[+]unlock queue
	[+]return 0
[-]tpDestroy:
	[-]if "tpDestroy was invoked" return //optional
	[-]try to lock destroy-mutex. if unable return
	[-]set indicator of "tpDestroy was invoked" to true
	_______________________________
	|if shouldWaitForTasks
	|[-]wait for the task queue to be empty(how?)
	|[-]lock queue
	|______________________________
	_______________________________
	|else (if should NOT WaitForTasks)
	|[-]lock queue
	|[-]dequeue all items
	|______________________________
	[-]enqueue "self destruct" function X number of threads
	[-]unlock queue
	[-]wait for all tasks to be done(how?)
	[-]free all allocated memory
	[-]unlock destroy-mutex//think about this
[+]tpCreate
	[+]allocate memory
	[+]update struct fields
		[+]create an empty queue
		[+]initialize all the locks and condition variables
		[+]other stuff...
	[+]create all the threads and set them to run the function all threads execute
	[+]return a pointer to the struct

----------------------------------------
additions to struct thread_pool:
[+]tasks queue
[+]lock for tasks queue (probably mutex)
[+]a way to indicate/signal that undone tasks exist (probably condition variable)
[+]indicator to know if tpDestroy was invoked
[+]int number of requested threads
[+]lock for tpDestroy to be invoked only once (mutex)

========================================
notes:
[+]need to add "#include <pthread.h>" probably to threadPool.h

*remember to compile with "–lpthread"

========================================
malloc's:
tpCreate 
	tp
tpInsertTask
	fap
	
free's:
selfDestruct
	fap
getAndExecuteTasksForever
	fap		***(also need to free in tpDestroy)

